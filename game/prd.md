뱀파이어 서바이벌 스타일 웹 게임 개발 설계
1. 개요
본 문서는 TypeScript(React, Next.js) 스택을 사용하여 뱀파이어 서바이벌 스타일의 웹 게임을 개발하기 위한 설계안입니다. Over-Engineering을 지양하고, 비즈니스 로직을 기능 단위로 그룹화하여 최소한의 복잡도로 구현하는 것을 목표로 합니다. 데스크탑과 모바일 환경 모두에서 플레이 가능하도록 반응형 조작 체계를 포함합니다.
프로젝트 목표: 플레이어가 적들로부터 살아남으며 레벨업을 통해 캐릭터를 강화하고, 최대한 높은 점수를 획득하는 웹 기반 슈팅 게임 개발
핵심 기능:
시간 및 킬 수에 기반한 점수 시스템
경험치 획득 및 레벨업에 따른 파워업 시스템
데스크탑(키보드) 및 모바일(가상 조이스틱)을 모두 지원하는 조작 체계
무한히 생성되는 일반 몬스터와 특정 조건에 따라 생성되는 보스 몬스터
기술 스택: Next.js, React, TypeScript
배포 환경: Vercel
2. 세부 유스케이스
유스케이스 ID	이름	설명
UC-01	게임 시작	- 사용자가 페이지에 접속하면 게임이 시작된다. <br> - 플레이어(luffy)가 화면 중앙에 생성된다. <br> - 게임 시간, 점수, 플레이어 상태(체력, 스탯)가 초기화되어 화면에 표시된다. <br> - 게임 루프가 시작되고 적(enemy)이 생성되기 시작한다.
UC-02	플레이어 조작	- (데스크탑) 사용자는 키보드(방향키 또는 WASD)를 사용해 플레이어를 상하좌우로 이동시킨다. <br> - (모바일) 사용자는 화면에 표시된 가상 조이스틱을 터치하여 플레이어를 이동시킨다. <br> - 플레이어는 게임 화면 밖으로 나갈 수 없다.
UC-03	적 생성 및 이동	- 일반 적(enemy1, enemy2, enemy3)이 화면 밖 임의의 위치에서 주기적으로 생성된다. <br> - 생성된 모든 적은 플레이어를 향해 일정한 속도로 다가온다. <br> - 일반 적을 50마리 처치할 때마다 보스(boss1, boss2)가 생성된다.
UC-04	자동 공격	- 플레이어는 현재 설정된 연사 속도(Fire Rate)에 따라 자동으로 투사체(akainu)를 발사한다. <br> - 투사체는 가장 가까운 적을 향하거나, 특정 방향으로 발사된다. (설계에 따라 선택)
UC-05	충돌 처리	- (투사체-적): 투사체가 적에게 닿으면 투사체는 사라지고 적은 처치된다. <br> - (플레이어-적): 플레이어가 적에게 닿으면 플레이어의 체력이 1 감소한다.
UC-06	점수 및 경험치 획득	- 적을 처치하면 점수와 경험치를 획득한다. (일반 적: 1점, 보스: 5점) <br> - 게임이 진행되는 시간에 따라서도 점수가 점진적으로 상승한다. <br> - 현재 점수와 시간은 화면 상단에 실시간으로 표시된다.
UC-07	레벨업 및 파워업	- 플레이어의 경험치가 요구치(10, 20, 40, 80...)에 도달하면 레벨업한다. <br> - 레벨업 시, 게임이 일시 정지되고 파워업 선택 화면(모달)이 나타난다. <br> - 사용자는 제시된 파워업(멀티플샷, 탄 크기 증가, 연사 속도 증가) 중 하나를 선택한다. <br> - 선택 즉시 플레이어의 능력치가 강화되고, 게임이 재개된다.
UC-08	게임 오버	- 플레이어의 체력(하트)이 0이 되면 게임이 종료된다. <br> - 게임 오버 화면에 최종 점수가 표시되며, '다시 시작' 버튼을 제공한다.
3. 주요 모듈 및 역할
게임을 효율적으로 관리하기 위해 로직을 상태 관리(Hooks), 렌더링(Components), 타입(Types) 세 가지 주요 관심사로 분리하여 설계합니다.
📁 /game (게임 로직 및 컴포넌트 루트)
└ 📁 /hooks (핵심 게임 로직 및 상태 관리)
useGameLoop.ts:
requestAnimationFrame을 사용하여 메인 게임 루프를 관리.
매 프레임마다 플레이어, 적, 투사체의 상태를 업데이트하고, 충돌 검사를 호출하는 역할.
게임의 상태(진행중, 일시정지, 게임오버)를 관리.
usePlayer.ts:
플레이어의 모든 상태(위치, 체력, 경험치, 스탯-샷수/탄크기/연사속도)를 관리.
플레이어 이동, 피격 처리, 경험치 획득 및 레벨업 로직을 포함.
useEnemies.ts:
모든 적(일반, 보스) 객체의 배열을 상태로 관리.
새로운 적을 생성(spawning)하고, 각 적의 이동 로직을 처리.
적 처치 로직(배열에서 제거)을 담당.
useProjectiles.ts:
화면에 존재하는 모든 투사체 객체의 배열을 상태로 관리.
플레이어의 스탯(연사속도, 샷수)에 기반하여 새로운 투사체를 생성.
각 투사체의 이동 및 화면 이탈 시 제거 로직을 처리.
useInput.ts:
키보드 이벤트(keydown, keyup)와 가상 조이스틱의 입력을 감지.
감지된 입력을 {x: 0, y: 1} 과 같은 표준화된 이동 벡터(vector) 값으로 변환하여 반환. 이를 통해 플레이어 조작 로직과 입력 방식을 분리.
└ 📁 /components (UI 및 렌더링)
GameCanvas.tsx:
실제 게임이 그려지는 주체. HTML5 <canvas> 엘리먼트를 사용.
위의 useGameLoop 훅을 사용하여 게임의 모든 개체(플레이어, 적, 투사체)를 렌더링.
게임의 최상위 컨테이너 역할.
HUD.tsx (Heads-Up Display):
게임 정보(점수, 시간, 플레이어 체력, 레벨, 스탯)를 화면에 표시하는 UI 컴포넌트.
게임 상태를 props로 받아 화면 상단 및 좌측 상단에 렌더링.
LevelUpModal.tsx:
레벨업 시 활성화되는 모달창.
플레이어에게 3가지 파워업 선택지를 버튼 형태로 제공.
사용자가 파워업을 선택하면, 해당 정보를 부모 컴포넌트로 전달.
VirtualJoystick.tsx:
모바일 환경에서만 렌더링되는 가상 조이스틱 UI 컴포넌트.
사용자의 터치 위치에 따라 이동 벡터 값을 계산하여 useInput 훅과 연동.
GameOverScreen.tsx:
게임 오버 시 활성화되는 화면.
최종 점수를 표시하고, 게임을 재시작하는 버튼을 제공.
└ 📁 /types (공용 타입 정의)
entities.ts:
게임에 등장하는 모든 개체(Entity)의 타입을 정의.
PlayerState, Enemy, Projectile 등의 인터페이스를 포함.
위치 { x: number, y: number }, 크기 { width: number, height: number } 등 공용 타입도 정의.
🗄️ 상태 관리 흐름
별도의 상태 관리 라이브러리(Redux, Zustand 등) 없이 React의 useState, useReducer, useContext를 조합하여 상태를 관리합니다. GameCanvas 컴포넌트에서 메인 게임 상태를 useReducer로 관리하고, 각 로직 훅(usePlayer, useEnemies 등)이 이 상태를 기반으로 동작하거나 상태 변경을 요청(dispatch)하는 구조를 가집니다. 이를 통해 복잡성을 낮추고 모듈 간의 결합도를 최소화합니다.